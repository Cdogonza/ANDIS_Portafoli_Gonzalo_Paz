# Unidad Temática 5 - Implementando Patrones de Diseño

## Preparación para la clase

La preparación para la clase no fue la suficiente porque el texto para leer era demasiado extenso y las actividades  en general eran muy largas.

## Temas de la unidad patrones y antipatrones de diseño

Esta unidad se basa en el estudio de los patrones de diseño y los antipatrones de diseño. Los patrones de diseño son soluciones a problemas comunes en el desarrollo de software, mientras que los antipatrones de diseño son soluciones a problemas comunes que no funcionan o que tienen consecuencias negativas en el desarrollo de software.

## SOLID

SOLID es un acrónimo que representa cinco principios básicos de la programación orientada a objetos y el diseño. Estos principios, cuando se aplican juntos, pretenden hacer que sea más fácil para un programador desarrollar software que sea fácil de mantener y extender. También se considera que los principios promueven la reutilización del código y la facilitación de la comunicación entre los miembros del equipo de desarrollo.

### Principio de responsabilidad única

El principio de responsabilidad única establece que cada clase o módulo en un programa debe tener la responsabilidad de una sola parte de la funcionalidad proporcionada por el software, y esa responsabilidad debe estar completamente encapsulada por la clase. Todos los servicios proporcionados por la clase deben ser coherentes con esa responsabilidad.

### Principio de abierto / cerrado

El principio abierto / cerrado establece que las clases o módulos de un programa deben ser abiertos para su extensión pero cerrados para su modificación. Esto significa que la funcionalidad existente debe ser modificada lo menos posible, y las nuevas funcionalidades deben ser agregadas en lugar de cambiar el código existente.

### Principio de sustitución de Liskov

El principio de sustitución de Liskov establece que los objetos en un programa deben ser reemplazables por instancias de sus subtipos sin alterar la funcionalidad del programa. Esto significa que los objetos deben ser diseñados de tal manera que cualquier propiedad o restricción que se aplique a un objeto en un programa también se aplique a los objetos de sus subtipos, sin que el programador tenga que preocuparse por ello.

### Principio de segregación de interfaz

El principio de segregación de interfaz establece que los clientes de un programa no deben verse obligados a depender de interfaces que no utilizan. Esto significa que los clientes no deben verse obligados a depender de métodos que no utilizan. Este principio se puede aplicar a clases, módulos, paquetes, etc.

### Principio de inversión de dependencia

El principio de inversión de dependencia establece que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Esto significa que los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones.
